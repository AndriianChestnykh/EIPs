---
eip: 
title: Standard interface for ZK verification
author: AndriianChestnykh (@AndriianChestnykh)
type: Standards Track
category: ERC
status: Draft
created: 2023-04-25
---

# Standard interface for ZK verification

# Abstract

This proposal aims to establish a standard method for zero-knowledge verification within smart contracts. This approach should simplify the adoption of on-chain KYC procedures. By using privacy features, developers can avoid revealing personal information such as name, social security number, company name, and exact token balance. However, smart contracts can still check for required attributes.

As an example use case, this method could enable an airdrop to users who do not reside in specific countries or are at least 18 years old.

# Motivation

Blockchain transactions are pseudonymous by nature, with only blockchain account addresses typically being publicly available. This is largely beneficial for privacy. However, an increasing number of dApps require on-chain support for KYC and other types of compliance validations, while still maintaining selective disclosure by publishing only the minimum necessary information on-chain and keeping the rest of users' personal data private.

**This document proposes the standardisation of smart contract extensions that enable the incorporation of an arbitrary set of zero-knowledge verifiers into contracts via inheritance mechanisms.** These contracts, such as those implementing the ERC20 or ERC771 interfaces, will maintain backward compatibility when extended with this functionality..

Every verifier is expected to have a Zero-Knowledge proof verification logic, as well as, optionally, a public inputs verification logic.

One of the most important verifier types is Self-Sovereign Identity (SSID) and claim verification, but it is not limited to those alone.

# Specification

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

A ZKP verifier smart contract, which embeds zero-knowledge verification according to this standard, SHOULD implement the `IZKPVerifier` interface. It brings a set of zero-knowledge verifiers associated with a contract via the `ZKPRequest` structure. The structure, in turn, SHOULD point to a circuit verifier contract, which SHOULD implement the `ICircuitVerifier` interface, and keep a set of params for public inputs verification. A `ZKPRequest` of specific `ICircuitVerifier`  and params is accounted by `requestId` identifier.

The circuit verifier contract MAY or MAY NOT check public inputs in the `inputs` argument and checks ZK proof by a Groth16 proving system in the `verify()` method. The Groth16 verifier can be auto generated by [SnarkJS](https://github.com/iden3/snarkjs) library from a Circom circuit.  *//TODO extend a contract to support any proving system*

Any ZKP verifier contract MAY be linked to more than one circuit verifier contract, e.g. in the following way `mapping(uint64 => IZKPVerifier.ZKPRequest) public requests;`

To keep a track of addresses, which passed the verification a ZKP verifier contract MAY include a dedicated state variable `mapping(address => mapping(uint64 => bool)) public proofs;`

```jsx
pragma solidity ^0.8.4;

import "./ICircuitVerifier.sol";

interface IZKPVerifier {
    /**
     * @dev Zero-Knowledge Proof request struct
     * @param verifier The verifier contract address
     * @param params The params for the verifier
     */
    struct ZKPRequest {
        ICircuitVerifier verifier;
        uint256[] params;
    }

    /**
     * @dev Stores a circuit verifier address and its params to validate public inputs,
     *      associates it with specific requestId.
     * @param requestId the request id
     * @param verifier the verifier contract address
     * @param params the params of the verifier
     */
    function setZKPRequest(
        uint64 requestId,
        ICircuitVerifier verifier,
        uint256[] memory params
    ) external;

    /**
     * @dev Calls associated circuit verifier contract with ZK proof and public inputs,
     *      stores the circuit verification results.
     * @param requestId the request id
     * @param inputs the public inputs of the circuit
     * @param a the a part of ZK proof
     * @param b the b part of ZK proof
     * @param c the c part of ZK proof
     */
    function submitZKPResponse(
        uint64 requestId,
        uint256[] memory inputs,
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c
    ) external;

    /**
     * @dev Returns circuit verifier address and its params by the requestId
     * @param requestId the request id
     * @return ZKPRequest struct
     */
    function getZKPRequest(uint64 requestId) external returns (ZKPRequest memory);
}
```

```jsx
pragma solidity ^0.8.4;

interface ICircuitVerifier {
    /**
     * @dev Implements public inputs verification with optional parametrisation by params (if not empty),
     *      calls a ZK verification contract.
     * @param inputs the public inputs of the circuit
     * @param a the a part of ZK proof
     * @param b the b part of ZK proof
     * @param c the c part of ZK proof
     */
    function verify(
        uint256[] memory inputs,
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[] memory params
    ) external view;

    /**
     * @dev Gets input index by name
     *
     * IMPORTANT: Note that the index is 0-based so avoid implementation mistakes for
     * missing indexes. It should rather throw but not return 0 value then.
     * The latter is, actually, the case, if input name -> index relation is implemented
     * as a mapping(string => uint256) in the contract.
     *
     * @param name The input name
     * @return the Input index
     */
    function inputIndexOf(string memory name) external view returns (uint256);

    /**
     * @dev Gets param index by name
     *
     * IMPORTANT: Note that the index is 0-based so avoid implementation mistakes for
     * missing indexes. It should rather throw but not return 0 value then.
     * The latter is, actually, the case, if param name -> index relation is implemented
     * as a mapping(string => uint256) in the contract.
     *
     * @param name The param name
     * @return the Param index
     */
    function paramIndexOf(string memory name) external view returns (uint256);
}
```

# Rationale

TBD

# Reference Implementation

Example ERC20 token dApp with ZK verification can be found in [this repo](https://github.com/0xPolygonID/erc-zk-verif-example).

# Security Considerations

TBD
